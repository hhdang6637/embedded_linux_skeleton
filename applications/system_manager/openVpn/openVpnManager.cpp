/*
 * openVpnManager.cpp
 *
 *  Created on: Jan 13, 2019
 *      Author: hhdang6637
 */

#include "openVpnManager.h"

#define OPENVPN_KEY_DB_PATH "/data/openvpndb/"
#define OPENVPN_CA_KEY OPENVPN_KEY_DB_PATH "ca.key"
#define OPENVPN_CA_CRT OPENVPN_KEY_DB_PATH "ca.crt"
#define OPENVPN_DH_PEM OPENVPN_KEY_DB_PATH "dh.pem"
#define OPENVPN_INDEX_TXT OPENVPN_KEY_DB_PATH "index.txt"
#define OPENVPN_SERIAL OPENVPN_KEY_DB_PATH "serial"
#define OPENVPN_TA_KEY OPENVPN_KEY_DB_PATH "ta.key"

#define OPENVPN_CONF "/tmp/confg/openvpn.conf"  // this will be generated by this module

static app::openvpnCfg_t openvpnCfg;

static bool openVpnManager_store() {
    return false;
}

static bool openVpnManager_load() {
    return false;
}

static void openvpnCfg_get_default(app::openvpnCfg_t *openvpnCfg_ptr) {
}

static void openvpnCfg_set_default(app::openvpnCfg_t *openvpnCfg_ptr) {
    openvpnCfg_ptr->state = 0;
    openvpnCfg_ptr->port = 1194;
}

static bool openvpnCfg_valid(app::openvpnCfg_t *openvpnCfg_ptr) {

    if (openvpnCfg_ptr->port < 1024 || openvpnCfg_ptr->port > 65535)
    {
        syslog(LOG_INFO, "port for vpn should from 1024 to 65535");
        return false;
    }

    return true;
}

static bool openVpnManager_rsa_key_is_ok(void) {
    // verify all rsa infatructer is ready to for openvpn before we generate openvpn.conf
    if(open("OPENVPN_CA_KEY", O_RDONLY) == -1)
    {
        syslog(LOG_ERR, "Do not have ca key");
        goto err_exist;
    }

    if(open("OPENVPN_CA_CRT", O_RDONLY) == -1)
    {
        syslog(LOG_ERR, "Do not have ca certificate");
        goto err_exist;
    }

    if(open("OPENVPN_DH_PEM", O_RDONLY) == -1)
    {
        syslog(LOG_ERR, "Do not have dh pem");
        goto err_exist;
    }

    if(open("OPENVPN_TA_KEY", O_RDONLY) == -1)
    {
        syslog(LOG_ERR, "Do not have ta key");
        goto err_exist;
    }

    if(open("OPENVPN_INDEX_TXT", O_RDONLY) == -1)
    {
        syslog(LOG_ERR, "Do not have index.txt");
        goto err_exist;
    }

    if(open("OPENVPN_SERIAL", O_RDONLY) == -1)
    {
        syslog(LOG_ERR, "Do not have serial");
        goto err_exist;
    }

    return true;

err_exist:
    return false;
}

static bool openVpnManager_generate_openvpncfg(void) {
    // generate openvpn.conf to OPENVPN_CONF
    mkdir(OPENVPN_CONF, 0755);

    std::ofstream openvpn_conf_file(OPENVPN_CONF);

    if (openvpn_conf_file.is_open())
    {
        openvpn_conf_file <<
                            "# listen on? (optional)\n"
                            ";local a.b.c.d\n"
                            "port 1194\n"
                            ";proto tcp\n"
                            "proto udp\n"
                            ";dev tap\n"
                            "dev tun\n"
                            ";dev-node MyTap\n"
                            "ca ca.crt\n"
                            "cert server.crt\n"
                            "key server.key\n"

                            "dh dh2048.pem\n"
                            ";topology subnet\n"

                            "server 10.8.0.0 255.255.255.0\n"
                            "ifconfig-pool-persist ipp.txt\n"
                            ";server-bridge 10.8.0.4 255.255.255.0 10.8.0.50 10.8.0.100\n"
                            ";server-bridge\n"
                            ";push \"route 192.168.10.0 255.255.255.0\"\n"
                            ";push \"route 192.168.20.0 255.255.255.0\"\n"

                            ";client-config-dir ccd\n"
                            ";route 192.168.40.128 255.255.255.248\n"
                            ";learn-address ./script\n"

                            "push \"redirect-gateway def1 bypass-dhcp\"\n"

                            "push \"dhcp-option DNS 208.67.222.222\"\n"
                            "push \"dhcp-option DNS 208.67.220.220\"\n"

                            ";client-to-client\n"

                            ";duplicate-cn\n"

                            "keepalive 10 120\n"

                            "tls-auth ta.key 0\n"
                            "key-direction 0\n"

                            ";cipher BF-CBC\n"
                            "cipher AES-128-CBC\n"
                            "auth SHA256\n"
                            ";cipher DES-EDE3-CBC\n"

                            "comp-lzo\n"

                            ";max-clients 100\n"

                            "user nobody\n"
                            "group nogroup\n"

                            "persist-key\n"
                            "persist-tun\n"

                            "status openvpn-status.log\n"

                            ";log         openvpn.log\n"
                            ";log-append  openvpn.log\n"

                            "verb 3\n"

                            ";mute 20\n";

        openvpn_conf_file.close();
    }

    return true;
}

static void openVpnManager_stop_openvpn_service(void) {
    // verify pid file and stop openvpn service

    if (open("OPENVPN_PID_FILE", O_RDONLY) == -1)
    {
        syslog(LOG_WARNING, "pid file do not exist");
    } else
    {
        std::string command;
        command = "killall -9 openvpn";
        system(command.c_str());
    }

}

static bool openVpnManager_start_openvpn_service(void) {
    // check config file is ready and start openvpn service
    if (open("OPENVPN_CONF", O_RDONLY) == -1)
    {
        syslog(LOG_ERR, "config file do not exist");
        return false;
    }

    std::string command;

    command = "/usr/sbin/openvpn --config";
    command += OPENVPN_CONF;
    command += "--daemon --writepid";
    command += OPENVPN_PID_FILE;
    system(command.c_str());

    return true;
}

static bool openvpn_cfg_handler (int socket_fd)
{
    app::rpcMessageOpenvpnCfg msgOpenvpnCfg;

    if (msgOpenvpnCfg.deserialize(socket_fd)) {

        if (msgOpenvpnCfg.getMsgAction() == app::rpcMessageOpenvpnCfgActionType::GET_OPENVPN_CFG) {
            app::openvpnCfg_t openvpnCfg_data;
            openVpnManager_openvpnCfg_get(&openvpnCfg_data); // nerver fail
            msgOpenvpnCfg.setOpenvpnCfg_data(openvpnCfg_data);
            msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);

        } else if (msgOpenvpnCfg.getMsgAction() == app::rpcMessageOpenvpnCfgActionType::SET_OPENVPN_CFG) {

            app::openvpnCfg_t openvpnCfg_data;
            msgOpenvpnCfg.getOpenvpnCfg_data(openvpnCfg_data);

            if (openVpnManager_openvpnCfg_set(&openvpnCfg_data)) {
                msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);
            } else {
                msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
            }

        } else {
            msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
        }

        return msgOpenvpnCfg.serialize(socket_fd);
    }

    return false;
}

void openVpnManager_init(app::rpcUnixServer &rpcServer) {
    openvpnCfg_set_default(&openvpnCfg);
    rpcServer.registerMessageHandler(app::rpcMessage::rpcMessageType::handle_openvpn_cfg, openvpn_cfg_handler);
}

bool openVpnManager_openvpnCfg_get(app::openvpnCfg_t *openvpnCfg_ptr) {

    if (openvpnCfg_ptr == NULL) {
        return false;
    }

    *openvpnCfg_ptr = openvpnCfg;

    return true;
}

bool openVpnManager_openvpnCfg_set(app::openvpnCfg_t *openvpnCfg_ptr) {

    bool config_changed;

    if (openvpnCfg_ptr == NULL) {
        syslog(LOG_CRIT, "openVpnManager_openvpnCfg_set: NULL pointer");
        return false;
    }

    if (openvpnCfg_valid(openvpnCfg_ptr)) {
        config_changed = memcmp (&openvpnCfg, openvpnCfg_ptr, sizeof(openvpnCfg)) != 0;
        openvpnCfg = *openvpnCfg_ptr;
    }

    if (config_changed) {
        openVpnManager_stop_openvpn_service();
    }

    if (openvpnCfg.state == false) {
        return true;
    }

    if (!openVpnManager_rsa_key_is_ok()) {
        syslog(LOG_ERR, "RSA Key Management is not ready for OpenVPN staring");
        goto err;
    }

    if (!openVpnManager_generate_openvpncfg()) {
        syslog(LOG_ERR, "Cannot create openvpn conf");
        goto err;
    }

    if (!openVpnManager_start_openvpn_service()) {
        syslog(LOG_ERR, "Cannot start openvpn service");
        goto err;
    }

    return true;

err:
    // any failes, set state back to false;
    openvpnCfg.state = false;
    return false;
}
