/*
 * openVpnManager.cpp
 *
 *  Created on: Jan 13, 2019
 *      Author: hhdang6637
 */
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fstream>
#include <sstream>

#include "ini.h"
#include "openVpnManager.h"
#include <sys/stat.h>
#include <string>
#include "rsa_util.h"
#include "utilities.h"

#define OPENVPN_DB_PATH "/data/openvpndb/"

#define OPENVPN_DB_PATH_KEY OPENVPN_DB_PATH "keys/"
#define OPENVPN_DB_PATH_CERTS OPENVPN_DB_PATH "certs/"
#define OPENVPN_DB_PATH_REQS OPENVPN_DB_PATH "reqs/"

#define OPENVPN_CA_KEY OPENVPN_DB_PATH_KEY "ca.key"
#define OPENVPN_SERVER_KEY OPENVPN_DB_PATH_KEY "server.key"

#define OPENVPN_CA_CRT OPENVPN_DB_PATH_CERTS "ca.crt"
#define OPENVPN_SEREVR_CERT OPENVPN_DB_PATH_CERTS "server.crt"

#define OPENVPN_SERVER_REQ OPENVPN_DB_PATH_REQS "server.csr"

#define OPENVPN_TLS_AUTH_PEM OPENVPN_DB_PATH "ta.key"
#define OPENVPN_DH_PEM OPENVPN_DB_PATH "dh.pem"
#define OPENVPN_INDEX_TXT OPENVPN_DB_PATH "index.txt"
#define OPENVPN_SERIAL OPENVPN_DB_PATH "serial"

#define OPENVPN_DB_PATH_CLIENTS OPENVPN_DB_PATH "clients/"
#define OPENVPN_DB_PATH_CLIENT_KEYS OPENVPN_DB_PATH_CLIENTS "keys/"
#define OPENVPN_DB_PATH_CLIENT_CERTS OPENVPN_DB_PATH_CLIENTS "certs/"
#define OPENVPN_DB_PATH_CLIENT_REQS OPENVPN_DB_PATH_CLIENTS "reqs/"
#define OPENVPN_DB_PATH_CLIENT_CONFIGS OPENVPN_DB_PATH_CLIENTS "configs/"

#define DAYS_EXPIRE 365
#define BITS_SIZE_CA 2048
#define BITS_SIZE_DH 4096
#define BITS_SIZE_SERVER 1024

#define CONFIG_DIR "/tmp/configs/"
#define OPENVPN_CONF_FILE CONFIG_DIR"openvpn.conf"  // this will be generated by this module
#define OPENVPN_PID_FILE "/var/run/openvpn.pid"

#define OPENVPN_PERSISTENT_CONFIG "/data/openvpn.conf"


static app::openvpnCfg_t openvpnCfg;
static app::openvpn_rsa_info_t rsa_info;

static bool openVpnManager_store()
{
    char sect[32];
    std::string value;
    app::ini openvpnConfIni;

    snprintf(sect, sizeof(sect), "openvpn");

    openvpnConfIni.set_int(sect, "state", openvpnCfg.state);
    openvpnConfIni.set_uint16(sect, "port", openvpnCfg.port);

    return openvpnConfIni.writeToFile(OPENVPN_PERSISTENT_CONFIG);
}

static bool openVpnManager_load()
{
    app::ini openvpnConfIni;

    if (openvpnConfIni.loadFromFile(OPENVPN_PERSISTENT_CONFIG)) {

        char sect[32];
        std::string value;

        snprintf(sect, sizeof(sect), "openvpn");

        if (openvpnConfIni.get_string(sect, "state", value)) {
            openvpnCfg.state = std::atoi(value.c_str());
        }

        if (openvpnConfIni.get_string(sect, "port", value)) {
            openvpnCfg.port = std::atoi(value.c_str());
        }

        return true;
    } else {
        syslog(LOG_NOTICE, "cannot load user config from /data/openvpn.conf, use default config");
    }

    return false;
}

static void openvpnCfg_get_default(app::openvpnCfg_t *openvpnCfg_ptr)
{
}

static void openvpnCfg_set_default(app::openvpnCfg_t *openvpnCfg_ptr)
{
    openvpnCfg_ptr->state = 0;
    openvpnCfg_ptr->port = 1194;
}

static void ca_subjects_load()
{
    if (!openssl_get_subject_crt(OPENVPN_CA_CRT, rsa_info.ca_subjects, sizeof(rsa_info.ca_subjects))) {
        syslog(LOG_INFO, "cannot load subjects from %s", OPENVPN_CA_CRT);
    }

    if (!openssl_get_subject_crt(OPENVPN_SEREVR_CERT, rsa_info.server_subjects, sizeof(rsa_info.server_subjects))) {
        syslog(LOG_INFO, "cannot load subjects from %s", OPENVPN_SEREVR_CERT);
    }

    syslog(LOG_INFO, "ca_subjects = %s\n", rsa_info.ca_subjects);
    syslog(LOG_INFO, "server_subjects = %s\n", rsa_info.server_subjects);
}

static bool openvpnCfg_valid(app::openvpnCfg_t *openvpnCfg_ptr)
{

    if (openvpnCfg_ptr->port < 1024 || openvpnCfg_ptr->port > 65535) {
        syslog(LOG_INFO, "VPN server port must be from 1024 to 65535");
        return false;
    }

    return true;
}

static bool openVpnManager_rsa_key_is_ok(void)
{
    // verify all rsa infatructer is ready to for openvpn before we generate openvpn.conf
    if (access(OPENVPN_CA_KEY, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_CA_KEY" not found");
        goto err_exit;
    }

    if(access(OPENVPN_SERVER_KEY, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_SERVER_KEY" not found");
        goto err_exit;
    }

    if(access(OPENVPN_CA_CRT, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_CA_CRT" not found");
        goto err_exit;
    }

    if (access(OPENVPN_DH_PEM, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_DH_PEM" not found");
        goto err_exit;
    }

    if(access(OPENVPN_TLS_AUTH_PEM, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_TLS_AUTH_PEM" not found");
        goto err_exit;
    }

    if (access(OPENVPN_INDEX_TXT, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_INDEX_TXT" not found");
        goto err_exit;
    }

    if (access(OPENVPN_SERIAL, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_SERIAL" not found");
        goto err_exit;
    }

    return true;

err_exit:
    return false;
}

static bool load_text_from_file(std::string &str, const char *txtfile)
{
    std::ifstream file(txtfile);

    if (file.is_open()) {
        std::stringstream str_stream;
        str_stream << file.rdbuf();
        str = str_stream.str();
        file.close();
        return true;
    }

    return false;
}

static bool openVpnManager_generate_openvpncfg(void)
{
    // generate openvpn.conf to OPENVPN_CONF_FILE
    std::string server_key;
    std::string ca_crt;
    std::string server_crt;
    std::string tls_auth;
    std::string dh_pa;

    load_text_from_file(server_key, OPENVPN_SERVER_KEY);
    load_text_from_file(ca_crt, OPENVPN_CA_CRT);
    load_text_from_file(server_crt, OPENVPN_SEREVR_CERT);
    load_text_from_file(tls_auth, OPENVPN_TLS_AUTH_PEM);
    load_text_from_file(dh_pa, OPENVPN_DH_PEM);

    mkdir(CONFIG_DIR, 0755);

    std::ofstream openvpn_conf_file(OPENVPN_CONF_FILE);

    if (openvpn_conf_file.is_open())
    {
        openvpn_conf_file <<
                            "port " << openvpnCfg.port << "\n" <<
                            "proto udp4\n"
                            "dev tun\n"\
                            // server key
                            "<key>\n"
                            << server_key <<
                            "</key>\n"
                            // ca cert
                            "<ca>\n"
                            << ca_crt <<
                            "</ca>\n"
                            // server cert
                            "<cert>\n"
                            << server_crt <<
                            "</cert>\n"
                            // tls-auth
                            "<tls-auth>\n"
                            << tls_auth <<
                            "</tls-auth>\n"
                            // tls-auth
                            "<dh>\n"
                            << dh_pa <<
                            "</dh>\n"

                            "server 10.8.0.0 255.255.255.0\n"
                            "ifconfig-pool-persist ipp.txt\n"
                            "push \"redirect-gateway def1 bypass-dhcp\"\n"
                            "push \"dhcp-option DNS 208.67.222.222\"\n"
                            "push \"dhcp-option DNS 208.67.220.220\"\n"
                            "keepalive 10 120\n"
                            "key-direction 0\n"
                            "cipher AES-128-CBC\n"
                            "auth SHA256\n"
                            // "comp-lzo\n"
                            "user nobody\n"
                            "group nogroup\n"
                            "persist-key\n"
                            "persist-tun\n"
                            "status /tmp/openvpn-status.log\n"
                            "verb 3\n";

        openvpn_conf_file.close();
    }

    return true;
}

static void openVpnManager_stop_openvpn_service(void)
{
    // verify pid file and stop openvpn service
    char cmd[32];
    pid_t openvpn_pid;

    openvpn_pid = get_pid_from_pidfile(OPENVPN_PID_FILE);
    if (openvpn_pid != -1) {
        snprintf(cmd, 32, "kill %d", openvpn_pid);
        system(cmd);
        sleep(1);
    }
}

static bool openVpnManager_start_openvpn_service(void)
{
    // check config file is ready and start openvpn service
    int rc;

    if (access(OPENVPN_CONF_FILE, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_CONF_FILE" not found");
        return false;
    }

    char openvpn_cmd[256];

    snprintf(openvpn_cmd, sizeof(openvpn_cmd), "/usr/sbin/openvpn --config %s "
             "--daemon --writepid %s",
             OPENVPN_CONF_FILE, OPENVPN_PID_FILE);

    rc = system(openvpn_cmd);

    syslog(LOG_INFO, "openVpnManager_start_openvpn_service: %s return %d\n", openvpn_cmd, rc);

    if (rc == 0) {
        return true;
    } else {
        return false;
    }

    return true;
}

static bool openvpn_gen_ta(const char* ta_key)
{
    int rc;
    char cmd_gen_ta[256];

    snprintf(cmd_gen_ta, sizeof(cmd_gen_ta), "openvpn --genkey --secret %s", ta_key);
    rc = system(cmd_gen_ta);
    if (rc == 0) {
        syslog(LOG_INFO, "openvpn_gen_ta: %s return %d\n", cmd_gen_ta, rc);
        return true;
    }

    return false;
}

static bool openvpn_get_client_info(std::list<app::openvpn_client_cert_t> &certs)
{
    // DB format
    // E|R|V<tab>Expiry<tab>[RevocationDate]<tab>Serial<tab>unknown<tab>SubjectDN
    app::openvpn_client_cert_t cert;
    char line[256];
    char subject[512];

    FILE *f = fopen(OPENVPN_INDEX_TXT, "r");
    if (f == NULL) {
        syslog(LOG_ERR, "cannot open: %s", OPENVPN_INDEX_TXT);
        return false;
    }

    while (fgets(line, sizeof(line), f) > 0) {
        cert = app::openvpn_client_cert_t();
        // V   710101000331Z           03      unknown /CN=Hien Nguyen/ST=HCM/C=VN/emailAddress=nmhien@gmail.com/O=Example Security/OU=IT Department
        if (sscanf(line, "%c %s %*s %*s /%[^\n]", &cert.state, cert.expire_date, subject) != 3) {
            continue; //  skip revoked certificates
        }

        openssl_subject_t subs = openssl_subject_parser(subject);
        string_copy(cert.common_name, subs["CN"], sizeof(cert.common_name));
        string_copy(cert.email, subs["emailAddress"], sizeof(cert.email));

        // skip the Server certificate
        if (strcmp(cert.common_name, "Server") == 0) {
            continue;
        }

        certs.push_back(cert);
    }

    fclose(f);
    return true;
}

static bool openvpn_gen_client_config(app::openvpn_client_config_t &client_config)
{
    std::string ca_crt, client_key, tls_auth, client_cert;
    char key[256], req[256], cert[256];

    std::string fileName(client_config.common_name);

    string_remove_spaces(fileName);

    snprintf(key, sizeof(key), OPENVPN_DB_PATH_CLIENT_KEYS "%s.key", fileName.c_str());
    snprintf(req, sizeof(req), OPENVPN_DB_PATH_CLIENT_REQS "%s.csr", fileName.c_str());
    snprintf(cert, sizeof(cert), OPENVPN_DB_PATH_CLIENT_CERTS "%s.crt", fileName.c_str());

    load_text_from_file(client_key, key);
    load_text_from_file(client_cert, cert);
    load_text_from_file(ca_crt, OPENVPN_CA_CRT);
    load_text_from_file(tls_auth, OPENVPN_TLS_AUTH_PEM);

    std::stringstream openvpn_client_cfg;

    openvpn_client_cfg << "client\n"
                       "remote example.com " << openvpnCfg.port << "\n"
                       << "proto udp4\n"
                       "dev tun\n"
                       "key-direction 1\n"
                       "cipher AES-128-CBC\n"
                       "auth SHA256\n"
                       "user nobody\n"
                       "group nogroup\n"
                       // CA cert
                       "<ca>\n" << ca_crt << "</ca>\n"
                       // client cert
                       "<cert>\n" << client_cert << "</cert>\n"
                       // client key
                       "<key>\n" << client_key << "</key>\n"
                       // tls-auth
                       "<tls-auth>\n" << tls_auth << "</tls-auth>\n";

    client_config.config_str = openvpn_client_cfg.str();

    return true;
}

static bool openvpn_gen_client(const app::openvpn_client_cert_t &client_cert)
{
    std::string fileName(client_cert.common_name);
    char key[256], req[256], cert[256];
    char subject[256];

    if (!openVpnManager_rsa_key_is_ok()) {
        syslog(LOG_ERR, "RSA Key Management is not ready for Gen client");
        goto err;
    }

    snprintf(subject, sizeof(subject),
             "/C=VN/ST=HCM/L=HCM/O=Example Security/OU=IT Department/CN=%s/emailAddress=%s",
             client_cert.common_name, client_cert.email);

    string_remove_spaces(fileName);

    snprintf(key, sizeof(key), OPENVPN_DB_PATH_CLIENT_KEYS "%s.key", fileName.c_str());
    snprintf(req, sizeof(req), OPENVPN_DB_PATH_CLIENT_REQS "%s.csr", fileName.c_str());
    snprintf(cert, sizeof(cert), OPENVPN_DB_PATH_CLIENT_CERTS "%s.crt", fileName.c_str());

    if (openssl_req(key, req, DAYS_EXPIRE, BITS_SIZE_SERVER, subject) == false) {
        syslog(LOG_ERR, "can NOT gen REQ for %s\n", req);
        goto err;
    }

    if (openssl_sign(OPENVPN_DB_PATH, req, cert, DAYS_EXPIRE) == false) {
        syslog(LOG_ERR, "can NOT SIGN req for %s\n", req);
        goto err;
    }

    return true;

err:
    return false;
}

static bool openvpn_revoke_client(const app::openvpn_client_cert_t &client_cert)
{
    char state;
    char serial[16];
    char line[256];
    char cmd_str[256];

    snprintf(cmd_str, sizeof(cmd_str), "cat %s | grep emailAddress=%s/O", OPENVPN_INDEX_TXT,
             client_cert.email);

    FILE *f = popen(cmd_str, "r");
    if (f == NULL) {
        syslog(LOG_ERR, "cannot run command : %s", cmd_str);
        return false;
    }

    while (fgets(line, sizeof(line), f) > 0) {
        // V   710101000331Z           03      unknown subjects
        if ((sscanf(line, "%c %*s %s %*s", &state, serial) != 2) && (state != 'V')) {
            continue;
        }

        if (openssl_revoke_ca(OPENVPN_DB_PATH, OPENVPN_DB_PATH_CERTS, serial) == true) {
            pclose(f);
            return true;
        }
    }

    syslog(LOG_INFO, "openvpn_revoke_client: cannot revoke certificate\n");
    pclose(f);
    return false;
}

static bool openvpn_client_init(const char* openssl_client_dir)
{
    char tmp_path[256];

    struct stat st;
    if (lstat(openssl_client_dir, &st) == -1) {
        mkdir(openssl_client_dir, 0755);
    } else if (!S_ISDIR(st.st_mode)) {
        syslog(LOG_ERR, "openvpn_client_init: %s is not a directory", openssl_client_dir);
        return false;
    }

    // make keys dir
    snprintf(tmp_path, sizeof(tmp_path), "%s/keys", openssl_client_dir);
    if (lstat(tmp_path, &st) == -1) {
        mkdir(tmp_path, 0755);
    } else if (!S_ISDIR(st.st_mode)) {
        syslog(LOG_ERR, "openvpn_client_init: %s is not a directory", tmp_path);
        return false;
    }

    // make cert dir
    snprintf(tmp_path, sizeof(tmp_path), "%s/certs", openssl_client_dir);
    if (lstat(tmp_path, &st) == -1) {
        mkdir(tmp_path, 0755);
    } else if (!S_ISDIR(st.st_mode)) {
        syslog(LOG_ERR, "openvpn_client_init: %s is not a directory", tmp_path);
        return false;
    }

    // make reqs dir
    snprintf(tmp_path, sizeof(tmp_path), "%s/reqs", openssl_client_dir);
    if (lstat(tmp_path, &st) == -1) {
        mkdir(tmp_path, 0755);
    } else if (!S_ISDIR(st.st_mode)) {
        syslog(LOG_ERR, "openvpn_client_init: %s is not a directory", tmp_path);
        return false;
    }

    // make configs dir
    snprintf(tmp_path, sizeof(tmp_path), "%s/configs", openssl_client_dir);
    if (lstat(tmp_path, &st) == -1) {
        mkdir(tmp_path, 0755);
    } else if (!S_ISDIR(st.st_mode)) {
        syslog(LOG_ERR, "openvpn_client_init: %s is not a directory", tmp_path);
        return false;
    }

    return true;
}

static bool init_rsa_database()
{
    if (openssl_ca_init(OPENVPN_DB_PATH) == false) {
        syslog(LOG_ERR, "can NOT init CA Directory: %s\n", OPENVPN_DB_PATH);
        goto err;
    }

    // Gen ca.key & ca.crt
    if (openssl_gen_ca(OPENVPN_DB_PATH, OPENVPN_CA_KEY, OPENVPN_CA_CRT, DAYS_EXPIRE, BITS_SIZE_CA) == false) {
        syslog(LOG_ERR, "can NOT gen CA\n");
        goto err;
    }

    // Request and sign cert for Server
    char subject[256];
    snprintf(subject, sizeof(subject), "%s",
             "/C=VN/ST=HCM/L=HCM/O=Example Security/OU=IT Department/CN=Server/emailAddress=server@gmail.com");
    if (openssl_req(OPENVPN_SERVER_KEY, OPENVPN_SERVER_REQ, DAYS_EXPIRE, BITS_SIZE_SERVER, subject) == false) {
        syslog(LOG_ERR, "can NOT gen REQ for %s\n", OPENVPN_SERVER_REQ);
        goto err;
    }

    if (openssl_sign(OPENVPN_DB_PATH, OPENVPN_SERVER_REQ, OPENVPN_SEREVR_CERT, DAYS_EXPIRE) == false) {
        syslog(LOG_ERR, "can NOT SIGN req for %s\n", OPENVPN_SERVER_REQ);
        goto err;
    }

    //Gen DH param
    if (openssl_gen_dh(OPENVPN_DH_PEM, BITS_SIZE_DH) == false) {
        syslog(LOG_ERR, "can NOT gen DH\n");
        goto err;
    }

    //Gen ta key
    if (openvpn_gen_ta(OPENVPN_TLS_AUTH_PEM) == false) {
        syslog(LOG_ERR, "can NOT gen TA key\n");
        goto err;
    }

    if (!openvpn_client_init(OPENVPN_DB_PATH_CLIENTS)) {
        syslog(LOG_ERR, OPENVPN_DB_PATH_CLIENTS " not found");
        goto err;
    }

    return true;

err:
    return false;
}

static bool openvpn_cfg_handler(int socket_fd)
{
    app::rpcMessageOpenvpnCfg msgOpenvpnCfg;

    if (msgOpenvpnCfg.deserialize(socket_fd)) {

        if (msgOpenvpnCfg.getMsgAction() == app::rpcMessageOpenvpnCfgActionType::GET_OPENVPN_CFG) {
            app::openvpnCfg_t openvpnCfg_data;
            openVpnManager_openvpnCfg_get(&openvpnCfg_data); // nerver fail
            msgOpenvpnCfg.setOpenvpnCfg_data(openvpnCfg_data);
            msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);

        } else if (msgOpenvpnCfg.getMsgAction() == app::rpcMessageOpenvpnCfgActionType::SET_OPENVPN_CFG) {

            app::openvpnCfg_t openvpnCfg_data;
            msgOpenvpnCfg.getOpenvpnCfg_data(openvpnCfg_data);

            if (openVpnManager_openvpnCfg_set(&openvpnCfg_data)) {
                msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);
            } else {
                msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
            }

        } else {
            msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
        }

        return msgOpenvpnCfg.serialize(socket_fd);
    }

    return false;
}

static bool openvpn_rsa_info_handler(int socket_fd)
{
    app::rpcMessageOpenvpnRsaInfo msgOpenvpnRsaInfo;

    if (msgOpenvpnRsaInfo.deserialize(socket_fd)) {

        if (msgOpenvpnRsaInfo.getMsgAction() == app::rpcMessageOpenvpnRsaInfoActionType::GET_OPENVPN_RSA_INFO) {
            app::openvpn_rsa_info_t openvpn_rsa_info;
            openVpnManager_rsa_info_get(&openvpn_rsa_info); // nerver fail
            msgOpenvpnRsaInfo.setOpenvpnRsaInfo(openvpn_rsa_info);
            msgOpenvpnRsaInfo.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);

        } else if (msgOpenvpnRsaInfo.getMsgAction() == app::rpcMessageOpenvpnRsaInfoActionType::SET_OPENVPN_RSA_INFO) {

            if (access(OPENVPN_DB_PATH, F_OK) == -1) {
                if (!init_rsa_database()) {
                    msgOpenvpnRsaInfo.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
                } else {
                    ca_subjects_load();
                    msgOpenvpnRsaInfo.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);
                }
            } else {
                if (system("rm -rf " OPENVPN_DB_PATH) != 0) {

                    syslog(LOG_ERR, "cannot remove the dir %s", OPENVPN_DB_PATH);
                    msgOpenvpnRsaInfo.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
                } else {
                    if (!init_rsa_database()) {
                        msgOpenvpnRsaInfo.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
                    } else {
                        ca_subjects_load();
                        msgOpenvpnRsaInfo.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);
                    }
                }
            }

        } else {
            msgOpenvpnRsaInfo.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
        }

        return msgOpenvpnRsaInfo.serialize(socket_fd);
    }

    return false;
}

static bool openvpn_client_certs_handler(int socket_fd)
{
    app::rpcMessageOpenvpnClientCerts msg;

    if (msg.deserialize(socket_fd)) {

        if (msg.getMsgAction() == app::rpcMessageOpenvpnClientCertActionType::GET_OPENVPN_CLIENT_CERT) {

            std::list<app::openvpn_client_cert_t> certs;
            if (openvpn_get_client_info(certs)) {
                msg.setOpenvpnClientCerts(certs);
                msg.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);
            } else {
                msg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
            }

        } else if (msg.getMsgAction() == app::rpcMessageOpenvpnClientCertActionType::GEN_OPENVPN_CLIENT_CERT) {

            if (!openvpn_gen_client(msg.getOpenvpnClientCert())) {
                msg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
            } else {
                msg.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);
            }

        } else if (msg.getMsgAction() == app::rpcMessageOpenvpnClientCertActionType::REVOKE_OPENVPN_CLIENT_CERT) {

            if (!openvpn_revoke_client(msg.getOpenvpnClientCert())) {
                msg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
            } else {
                msg.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);
            }

        } else if (msg.getMsgAction() == app::rpcMessageOpenvpnClientCertActionType::GEN_OPENVPN_CLIENT_CONFIG) {

            app::openvpn_client_config_t cfg = msg.getOpenvpnClientConfig();
            if (openvpn_gen_client_config(cfg) == false) {
                msg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
            } else {
                msg.setOpenvpnClientConfig(cfg);
                msg.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);
            }

        } else {
            msg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
        }

        return msg.serialize(socket_fd);
    }

    return false;
}

void openVpnManager_init(app::rpcUnixServer &rpcServer)
{
    ca_subjects_load();
    openvpnCfg_set_default(&openvpnCfg);
    if ((openVpnManager_load() == true) && (openvpnCfg.state == 1)) {
        if (!openVpnManager_rsa_key_is_ok()) {
            syslog(LOG_ERR, "RSA Key Management is not ready for OpenVPN staring");
        }
        if (!openVpnManager_generate_openvpncfg()) {
            syslog(LOG_ERR, "Cannot create openvpn conf");
        }
        if (!openVpnManager_start_openvpn_service()) {
            syslog(LOG_ERR, "Cannot start openvpn service");
            openvpnCfg.state = false;
        }
    }

    rpcServer.registerMessageHandler(app::rpcMessage::rpcMessageType::handle_openvpn_cfg, openvpn_cfg_handler);
    rpcServer.registerMessageHandler(app::rpcMessage::rpcMessageType::handle_openvpn_rsa_info, openvpn_rsa_info_handler);
    rpcServer.registerMessageHandler(app::rpcMessage::rpcMessageType::handle_openvpn_cert_clients, openvpn_client_certs_handler);
}

bool openVpnManager_openvpnCfg_get(app::openvpnCfg_t *openvpnCfg_ptr)
{

    if (openvpnCfg_ptr == NULL) {
        return false;
    }

    *openvpnCfg_ptr = openvpnCfg;

    return true;
}

bool openVpnManager_openvpnCfg_set(app::openvpnCfg_t *openvpnCfg_ptr)
{

    bool config_changed;

    if (openvpnCfg_ptr == NULL) {
        syslog(LOG_CRIT, "openVpnManager_openvpnCfg_set: NULL pointer");
        return false;
    }

    if (openvpnCfg_valid(openvpnCfg_ptr)) {
        config_changed = memcmp(&openvpnCfg, openvpnCfg_ptr, sizeof(openvpnCfg)) != 0;
        openvpnCfg = *openvpnCfg_ptr;
    }

    if (config_changed) {
        if (openVpnManager_store() != true) {
            syslog(LOG_ERR, "cannot save openvpn config");
        }
        openVpnManager_stop_openvpn_service();
    }

    if (openvpnCfg.state == false) {
        return true;
    }

    if (!openVpnManager_rsa_key_is_ok()) {
        syslog(LOG_ERR, "RSA Key Management is not ready for OpenVPN staring");
        goto err;
    }

    if (!openVpnManager_generate_openvpncfg()) {
        syslog(LOG_ERR, "Cannot create openvpn conf");
        goto err;
    }

    if (!openVpnManager_start_openvpn_service()) {
        syslog(LOG_ERR, "Cannot start openvpn service");
        goto err;
    }

    return true;

err:
    // any failes, set state back to false;
    openvpnCfg.state = false;

    return false;
}

bool openVpnManager_rsa_info_get(app::openvpn_rsa_info_t *openvpn_rsa_info)
{
    if (openvpn_rsa_info == NULL) {
        return false;
    }

    *openvpn_rsa_info = rsa_info;
    return true;
}
