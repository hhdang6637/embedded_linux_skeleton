/*
 * openVpnManager.cpp
 *
 *  Created on: Jan 13, 2019
 *      Author: hhdang6637
 */

#include "openVpnManager.h"

#define OPENVPN_KEY_DB_PATH "/data/openvpndb/"
#define OPENVPN_CA_KEY OPENVPN_KEY_DB_PATH "ca.key"
#define OPENVPN_CA_CRT OPENVPN_KEY_DB_PATH "ca.crt"
#define OPENVPN_DH_PEM OPENVPN_KEY_DB_PATH "dh.pem"
#define OPENVPN_INDEX_TXT OPENVPN_KEY_DB_PATH "index.txt"
#define OPENVPN_SERIAL OPENVPN_KEY_DB_PATH "serial"
#define OPENVPN_TA_KEY OPENVPN_KEY_DB_PATH "ta.key"

#define OPENVPN_CONF "/tmp/confg/openvpn.conf"  // this will be generated by this module

static app::openvpnCfg_t openvpnCfg;

static bool openVpnManager_store() {
    return false;
}

static bool openVpnManager_load() {
    return false;
}

static void openvpnCfg_get_default(app::openvpnCfg_t *openvpnCfg_ptr) {
}

static void openvpnCfg_set_default(app::openvpnCfg_t *openvpnCfg_ptr) {
    openvpnCfg_ptr->state = 0;
    openvpnCfg_ptr->port = 1194;
}

static bool openvpnCfg_valid(app::openvpnCfg_t *openvpnCfg_ptr) {

    if (openvpnCfg_ptr->port < 1024 || openvpnCfg_ptr->port > 65535)
    {
        syslog(LOG_INFO, "port for vpn should from 1024 to 65535");
        return false;
    }

    return true;
}

static bool openVpnManager_rsa_key_is_ok(void) {
    // verify all rsa infatructer is ready to for openvpn before we generate openvpn.conf
    return false;
}

static bool openVpnManager_generate_openvpncfg(void) {
    // generate openvpn.conf to OPENVPN_CONF
    return false;
}

static void openVpnManager_stop_openvpn_service(void) {
    // verify pid file and stop openvpn service
}

static bool openVpnManager_start_openvpn_service(void) {
    // check config file is ready and start openvpn service
    return false;
}

static bool openvpn_cfg_handler (int socket_fd)
{
    app::rpcMessageOpenvpnCfg msgOpenvpnCfg;

    if (msgOpenvpnCfg.deserialize(socket_fd)) {

        if (msgOpenvpnCfg.getMsgAction() == app::rpcMessageOpenvpnCfgActionType::GET_OPENVPN_CFG) {
            app::openvpnCfg_t openvpnCfg_data;
            openVpnManager_openvpnCfg_get(&openvpnCfg_data); // nerver fail
            msgOpenvpnCfg.setOpenvpnCfg_data(openvpnCfg_data);
            msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);

        } else if (msgOpenvpnCfg.getMsgAction() == app::rpcMessageOpenvpnCfgActionType::SET_OPENVPN_CFG) {

            app::openvpnCfg_t openvpnCfg_data;
            msgOpenvpnCfg.getOpenvpnCfg_data(openvpnCfg_data);

            if (openVpnManager_openvpnCfg_set(&openvpnCfg_data)) {
                msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);
            } else {
                msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
            }

        } else {
            msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
        }

        return msgOpenvpnCfg.serialize(socket_fd);
    }

    return false;
}

void openVpnManager_init(app::rpcUnixServer &rpcServer) {
    openvpnCfg_set_default(&openvpnCfg);
    rpcServer.registerMessageHandler(app::rpcMessage::rpcMessageType::handle_openvpn_cfg, openvpn_cfg_handler);
}

bool openVpnManager_openvpnCfg_get(app::openvpnCfg_t *openvpnCfg_ptr) {

    if (openvpnCfg_ptr == NULL) {
        return false;
    }

    *openvpnCfg_ptr = openvpnCfg;

    return true;
}

bool openVpnManager_openvpnCfg_set(app::openvpnCfg_t *openvpnCfg_ptr) {

    bool config_changed;

    if (openvpnCfg_ptr == NULL) {
        syslog(LOG_CRIT, "openVpnManager_openvpnCfg_set: NULL pointer");
        return false;
    }

    if (openvpnCfg_valid(openvpnCfg_ptr)) {
        config_changed = memcmp (&openvpnCfg, openvpnCfg_ptr, sizeof(openvpnCfg)) != 0;
        openvpnCfg = *openvpnCfg_ptr;
    }

    if (config_changed) {
        openVpnManager_stop_openvpn_service();
    }

    if (openvpnCfg.state == false) {
        return true;
    }

    if (!openVpnManager_rsa_key_is_ok()) {
        syslog(LOG_ERR, "RSA Key Management is not ready for OpenVPN staring");
        goto err;
    }

    if (!openVpnManager_generate_openvpncfg()) {
        syslog(LOG_ERR, "Cannot create openvpn conf");
        goto err;
    }

    if (!openVpnManager_start_openvpn_service()) {
        syslog(LOG_ERR, "Cannot start openvpn service");
        goto err;
    }

    return true;

err:
    // any failes, set state back to false;
    openvpnCfg.state = false;
    return false;
}
