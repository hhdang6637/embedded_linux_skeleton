/*
 * openVpnManager.cpp
 *
 *  Created on: Jan 13, 2019
 *      Author: hhdang6637
 */
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fstream>
#include <sstream>

#include "openVpnManager.h"
#include <sys/stat.h>
#include <string>

#define OPENVPN_DB_PATH "/data/openvpndb/"
#define OPENVPN_DB_PATH_KEY OPENVPN_DB_PATH "keys/"
#define OPENVPN_DB_PATH_CERTS OPENVPN_DB_PATH "certs/"
#define OPENVPN_CA_KEY OPENVPN_DB_PATH_KEY "ca.key"
#define OPENVPN_SERVER_KEY OPENVPN_DB_PATH_KEY "server.key"
#define OPENVPN_CA_CRT OPENVPN_DB_PATH_CERTS "ca.crt"
#define OPENVPN_SERVER_CRT OPENVPN_DB_PATH_CERTS "server.crt"
#define OPENVPN_TLS_AUTH_PEM OPENVPN_DB_PATH "ta.key"
#define OPENVPN_DH_PEM OPENVPN_DB_PATH "dh.pem"
#define OPENVPN_INDEX_TXT OPENVPN_DB_PATH "index.txt"
#define OPENVPN_SERIAL OPENVPN_DB_PATH "serial"

#define CONFIG_DIR "/tmp/configs/"
#define OPENVPN_CONF_FILE CONFIG_DIR"openvpn.conf"  // this will be generated by this module

static app::openvpnCfg_t openvpnCfg;

static bool openVpnManager_store() {
    return false;
}

static bool openVpnManager_load() {
    return false;
}

static void openvpnCfg_get_default(app::openvpnCfg_t *openvpnCfg_ptr) {
}

static void openvpnCfg_set_default(app::openvpnCfg_t *openvpnCfg_ptr) {
    openvpnCfg_ptr->state = 0;
    openvpnCfg_ptr->port = 1194;
}

static bool openvpnCfg_valid(app::openvpnCfg_t *openvpnCfg_ptr) {

    if (openvpnCfg_ptr->port < 1024 || openvpnCfg_ptr->port > 65535)
    {
        syslog(LOG_INFO, "VPN server port must be from 1024 to 65535");
        return false;
    }

    return true;
}

static bool openVpnManager_rsa_key_is_ok(void) {
    // verify all rsa infatructer is ready to for openvpn before we generate openvpn.conf
    if(access(OPENVPN_CA_KEY, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_CA_KEY" not found");
        goto err_exist;
    }

    if(access(OPENVPN_SERVER_KEY, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_SERVER_KEY" not found");
        goto err_exist;
    }

    if(access(OPENVPN_CA_CRT, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_CA_CRT" not found");
        goto err_exist;
    }

    if(access(OPENVPN_DH_PEM, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_DH_PEM" not found");
        goto err_exist;
    }

    if(access(OPENVPN_TLS_AUTH_PEM, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_TLS_AUTH_PEM" not found");
        goto err_exist;
    }

    if(access(OPENVPN_INDEX_TXT, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_INDEX_TXT" not found");
        goto err_exist;
    }

    if(access(OPENVPN_SERIAL, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_SERIAL" not found");
        goto err_exist;
    }

    return true;

err_exist:
    return false;
}

bool load_text_from_file(std::string &str, const char *txtfile) {

    std::ifstream file;
    file.open(txtfile);

    std::stringstream str_stream;

    str_stream << file.rdbuf();
    str = str_stream.str();

    return false;
}

static bool openVpnManager_generate_openvpncfg(void) {
    // generate openvpn.conf to OPENVPN_CONF_FILE
    std::string server_key;
    std::string ca_crt;
    std::string server_crt;
    std::string tls_auth;
    std::string dh_pa;

    load_text_from_file(server_key, OPENVPN_SERVER_KEY);
    load_text_from_file(ca_crt, OPENVPN_CA_CRT);
    load_text_from_file(server_crt, OPENVPN_SERVER_CRT);
    load_text_from_file(tls_auth, OPENVPN_TLS_AUTH_PEM);
    load_text_from_file(dh_pa, OPENVPN_DH_PEM);

    mkdir(CONFIG_DIR, 0755);

    std::ofstream openvpn_conf_file(OPENVPN_CONF_FILE);

    if (openvpn_conf_file.is_open())
    {
        openvpn_conf_file <<
                            "port " << openvpnCfg.port << "\n" <<
                            "proto udp\n"
                            "dev tun\n"\
                            // server key
                            "<key>\n"
                            << server_key <<
                            "</key>\n"
                            // ca cert
                            "<ca>\n"
                            << ca_crt <<
                            "</ca>\n"
                            // server cert
                            "<cert>\n"
                            << server_crt <<
                            "</cert>\n"
                            // tls-auth
                            "<tls-auth>\n"
                            << tls_auth <<
                            "</tls-auth>\n"
                            // tls-auth
                            "<dh>\n"
                            << dh_pa <<
                            "</dh>\n"

                            "server 10.8.0.0 255.255.255.0\n"
                            "ifconfig-pool-persist ipp.txt\n"
                            "push \"redirect-gateway def1 bypass-dhcp\"\n"
                            "push \"dhcp-option DNS 208.67.222.222\"\n"
                            "push \"dhcp-option DNS 208.67.220.220\"\n"
                            "keepalive 10 120\n"
                            "key-direction 0\n"
                            "cipher AES-128-CBC\n"
                            "auth SHA256\n"
                            // "comp-lzo\n"
                            "user nobody\n"
                            "group nogroup\n"
                            "persist-key\n"
                            "persist-tun\n"
                            "status /tmp/openvpn-status.log\n"
                            "verb 3\n";

        openvpn_conf_file.close();
    }

    return true;
}

static void openVpnManager_stop_openvpn_service(void) {
    // verify pid file and stop openvpn service
    if (access("/var/run/openvpn.pid", F_OK) != -1) {
        system("killall openvpn");
    }
}

static bool openVpnManager_start_openvpn_service(void) {
    // check config file is ready and start openvpn service
    int rc;

    if (access(OPENVPN_CONF_FILE, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_CONF_FILE" not found");
        return false;
    }

    char openvpn_cmd[256];

    snprintf(openvpn_cmd, sizeof(openvpn_cmd),
        "/usr/sbin/openvpn --config %s "
        "--daemon --writepid /var/run/openvpn.pid", OPENVPN_CONF_FILE);

    rc = system(openvpn_cmd);

    syslog(LOG_INFO, "openVpnManager_start_openvpn_service: %s return %d\n", openvpn_cmd, rc);

    if(rc == 0) {
        return true;
    } else {
        return false;
    }

    return true;
}

static bool openvpn_cfg_handler (int socket_fd)
{
    app::rpcMessageOpenvpnCfg msgOpenvpnCfg;

    if (msgOpenvpnCfg.deserialize(socket_fd)) {

        if (msgOpenvpnCfg.getMsgAction() == app::rpcMessageOpenvpnCfgActionType::GET_OPENVPN_CFG) {
            app::openvpnCfg_t openvpnCfg_data;
            openVpnManager_openvpnCfg_get(&openvpnCfg_data); // nerver fail
            msgOpenvpnCfg.setOpenvpnCfg_data(openvpnCfg_data);
            msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);

        } else if (msgOpenvpnCfg.getMsgAction() == app::rpcMessageOpenvpnCfgActionType::SET_OPENVPN_CFG) {

            app::openvpnCfg_t openvpnCfg_data;
            msgOpenvpnCfg.getOpenvpnCfg_data(openvpnCfg_data);

            if (openVpnManager_openvpnCfg_set(&openvpnCfg_data)) {
                msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);
            } else {
                msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
            }

        } else {
            msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
        }

        return msgOpenvpnCfg.serialize(socket_fd);
    }

    return false;
}

void openVpnManager_init(app::rpcUnixServer &rpcServer) {
    openvpnCfg_set_default(&openvpnCfg);
    rpcServer.registerMessageHandler(app::rpcMessage::rpcMessageType::handle_openvpn_cfg, openvpn_cfg_handler);
}

bool openVpnManager_openvpnCfg_get(app::openvpnCfg_t *openvpnCfg_ptr) {

    if (openvpnCfg_ptr == NULL) {
        return false;
    }

    *openvpnCfg_ptr = openvpnCfg;

    return true;
}

bool openVpnManager_openvpnCfg_set(app::openvpnCfg_t *openvpnCfg_ptr) {

    bool config_changed;

    if (openvpnCfg_ptr == NULL) {
        syslog(LOG_CRIT, "openVpnManager_openvpnCfg_set: NULL pointer");
        return false;
    }

    if (openvpnCfg_valid(openvpnCfg_ptr)) {
        config_changed = memcmp (&openvpnCfg, openvpnCfg_ptr, sizeof(openvpnCfg)) != 0;
        openvpnCfg = *openvpnCfg_ptr;
    }

    if (config_changed) {
        openVpnManager_stop_openvpn_service();
    }

    if (openvpnCfg.state == false) {
        return true;
    }

    if (!openVpnManager_rsa_key_is_ok()) {
        syslog(LOG_ERR, "RSA Key Management is not ready for OpenVPN staring");
        goto err;
    }

    if (!openVpnManager_generate_openvpncfg()) {
        syslog(LOG_ERR, "Cannot create openvpn conf");
        goto err;
    }

    if (!openVpnManager_start_openvpn_service()) {
        syslog(LOG_ERR, "Cannot start openvpn service");
        goto err;
    }

    return true;

err:
    // any failes, set state back to false;
    openvpnCfg.state = false;

    return false;
}
