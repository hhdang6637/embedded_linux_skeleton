/*
 * openVpnManager.cpp
 *
 *  Created on: Jan 13, 2019
 *      Author: hhdang6637
 */
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fstream>

#include "openVpnManager.h"
#include <sys/stat.h>
#include <string>
#include "rsa_util.h"

#define OPENVPN_KEY_DB_PATH "/data/openvpndb/"
#define OPENSSL_CA_DIR OPENVPN_KEY_DB_PATH

#define OPENVPN_CA_KEY OPENSSL_CA_DIR "keys/ca.key"
#define OPENVPN_CA_CRT OPENSSL_CA_DIR "certs/ca.crt"
#define OPENVPN_DH_PEM OPENSSL_CA_DIR "dh.pem"
#define OPENVPN_TA_KEY OPENSSL_CA_DIR "ta.key"
#define OPENVPN_INDEX_TXT OPENSSL_CA_DIR "index.txt"
#define OPENVPN_SERIAL OPENSSL_CA_DIR "serial"
#define OPENVPN_SERVER_KEY OPENSSL_CA_DIR "keys/server.key"
#define OPENVPN_SEREVR_CERT OPENSSL_CA_DIR "certs/server.crt"
#define OPENVPN_SERVER_REQ OPENSSL_CA_DIR "reqs/server.csr"
#define DAYS_EXPIRE 365
#define BITS_SIZE_CA 4096
#define BITS_SIZE_DH 4096
#define BITS_SIZE_SERVER 1024


#define CONFIG_DIR "/tmp/configs/"
#define OPENVPN_CONF_FILE CONFIG_DIR"openvpn.conf"  // this will be generated by this module

static app::openvpnCfg_t openvpnCfg;

static bool openVpnManager_store() {
    return false;
}

static bool openVpnManager_load() {
    return false;
}

static void openvpnCfg_get_default(app::openvpnCfg_t *openvpnCfg_ptr) {
}

static void openvpnCfg_set_default(app::openvpnCfg_t *openvpnCfg_ptr) {
    openvpnCfg_ptr->state = 0;
    openvpnCfg_ptr->port = 1194;
}

static bool openvpnCfg_valid(app::openvpnCfg_t *openvpnCfg_ptr) {

    if (openvpnCfg_ptr->port < 1024 || openvpnCfg_ptr->port > 65535)
    {
        syslog(LOG_INFO, "VPN server port must be from 1024 to 65535");
        return false;
    }

    return true;
}

static bool openVpnManager_rsa_key_is_ok(void) {
    // verify all rsa infatructer is ready to for openvpn before we generate openvpn.conf
    if(access(OPENVPN_CA_KEY, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_CA_KEY" not found");
        goto err_exist;
    }

    if(access(OPENVPN_CA_CRT, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_CA_CRT" not found");
        goto err_exist;
    }

    if(access(OPENVPN_DH_PEM, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_DH_PEM" not found");
        goto err_exist;
    }

    if(access(OPENVPN_TA_KEY, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_TA_KEY" not found");
        goto err_exist;
    }

    if(access(OPENVPN_INDEX_TXT, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_INDEX_TXT" not found");
        goto err_exist;
    }

    if(access(OPENVPN_SERIAL, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_SERIAL" not found");
        goto err_exist;
    }

    return true;

err_exist:
    return false;
}

static bool openVpnManager_generate_openvpncfg(void) {
    // generate openvpn.conf to OPENVPN_CONF_FILE
    mkdir(CONFIG_DIR, 0755);

    std::ofstream openvpn_conf_file(OPENVPN_CONF_FILE);

    if (openvpn_conf_file.is_open())
    {
        openvpn_conf_file <<
                            "port 1194\n"
                            "proto udp\n"
                            "dev tun\n"
                            "ca ca.crt\n"
                            "cert server.crt\n"
                            "key server.key\n"
                            "tls-auth ta.key 0\n"
                            "dh dh2048.pem\n"
                            "server 10.8.0.0 255.255.255.0\n"
                            "ifconfig-pool-persist ipp.txt\n"
                            "push \"redirect-gateway def1 bypass-dhcp\"\n"
                            "push \"dhcp-option DNS 208.67.222.222\"\n"
                            "push \"dhcp-option DNS 208.67.220.220\"\n"
                            "keepalive 10 120\n"
                            "key-direction 0\n"
                            "cipher AES-128-CBC\n"
                            "auth SHA256\n"
                            // "comp-lzo\n"
                            "user nobody\n"
                            "group nogroup\n"
                            "persist-key\n"
                            "persist-tun\n"
                            "status /tmp/openvpn-status.log\n"
                            "verb 3\n";

        openvpn_conf_file.close();
    }

    return true;
}

static void openVpnManager_stop_openvpn_service(void) {
    // verify pid file and stop openvpn service
    if (access("/var/run/openvpn.pid", F_OK) != -1) {
        system("killall openvpn");
    }
}

static bool openVpnManager_start_openvpn_service(void) {
    // check config file is ready and start openvpn service
    int rc;

    if (access(OPENVPN_CONF_FILE, F_OK) == -1) {
        syslog(LOG_ERR, OPENVPN_CONF_FILE" not found");
        return false;
    }

    char openvpn_cmd[256];

    snprintf(openvpn_cmd, sizeof(openvpn_cmd),
        "/usr/sbin/openvpn --config %s "
        "--daemon --writepid /var/run/openvpn.pid", OPENVPN_CONF_FILE);

    rc = system(openvpn_cmd);

    syslog(LOG_INFO, "openVpnManager_start_openvpn_service: %s return %d\n", openvpn_cmd, rc);

    if(rc == 0) {
        return true;
    } else {
        return false;
    }

    return true;
}

static bool openvpn_gen_ta(const char* ta_key)
{
    int rc;
    char cmd_gen_ta[256];

    snprintf(cmd_gen_ta, sizeof(cmd_gen_ta), "openvpn --genkey --secret %s", ta_key);
    rc = system(cmd_gen_ta);
    if(rc == 0)
    {
        syslog(LOG_INFO, "openvpn_gen_ta: %s return %d\n",
        cmd_gen_ta, rc);
        return true;
    }

    return false;
}

static bool init_rsa_database()
{
    if(openssl_ca_init(OPENSSL_CA_DIR) == false)
    {
        syslog(LOG_ERR, "can NOT init CA Directory: %s\n", OPENSSL_CA_DIR);
        goto err;
    }

    // Gen ca.key & ca.crt
    if(openssl_gen_ca(OPENSSL_CA_DIR, OPENVPN_CA_KEY, OPENVPN_CA_CRT, DAYS_EXPIRE, BITS_SIZE_CA) == false)
    {
        syslog(LOG_ERR, "can NOT gen CA\n");
        goto err;
    }

    // Request and sign cert for Server
    char subject[256];
    snprintf(subject, sizeof(subject), "%s","/C=VN/ST=HCM/L=HCM/O=Example Security/OU=IT Department/CN=example.com/emailAddress=server@gmail.com");
    if(openssl_req(OPENVPN_SERVER_KEY, OPENVPN_SERVER_REQ, DAYS_EXPIRE, BITS_SIZE_SERVER, subject) == false)
    {
        syslog(LOG_ERR, "can NOT gen REQ for %s\n", OPENVPN_SERVER_REQ);
        goto err;
    }

    if(openssl_sign(OPENSSL_CA_DIR, OPENVPN_SERVER_REQ, OPENVPN_SEREVR_CERT, DAYS_EXPIRE) == false)
    {
        syslog(LOG_ERR, "can NOT SIGN req for %s\n", OPENVPN_SERVER_REQ);
        goto err;
    }

    //Gen DH param
    if(openssl_gen_dh(OPENVPN_DH_PEM, BITS_SIZE_DH) == false)
    {
        syslog(LOG_ERR, "can NOT gen DH\n");
        goto err;
    }

    //Gen ta key
    if(openvpn_gen_ta(OPENVPN_TA_KEY) == false)
    {
        syslog(LOG_ERR, "can NOT gen TA key\n");
        goto err;
    }

    return true;

err:
    return false;
}

static bool openvpn_cfg_handler (int socket_fd)
{
    app::rpcMessageOpenvpnCfg msgOpenvpnCfg;

    if (msgOpenvpnCfg.deserialize(socket_fd)) {

        if (msgOpenvpnCfg.getMsgAction() == app::rpcMessageOpenvpnCfgActionType::GET_OPENVPN_CFG) {
            app::openvpnCfg_t openvpnCfg_data;
            openVpnManager_openvpnCfg_get(&openvpnCfg_data); // nerver fail
            msgOpenvpnCfg.setOpenvpnCfg_data(openvpnCfg_data);
            msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);

        } else if (msgOpenvpnCfg.getMsgAction() == app::rpcMessageOpenvpnCfgActionType::SET_OPENVPN_CFG) {

            app::openvpnCfg_t openvpnCfg_data;
            msgOpenvpnCfg.getOpenvpnCfg_data(openvpnCfg_data);

            if (openVpnManager_openvpnCfg_set(&openvpnCfg_data)) {
                msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::SUCCESS);
            } else {
                msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
            }

        } else {
            msgOpenvpnCfg.setMsgResult(app::rpcMessageOpenvpnResultType::FAILED);
        }

        return msgOpenvpnCfg.serialize(socket_fd);
    }

    return false;
}

void openVpnManager_init(app::rpcUnixServer &rpcServer) {
    openvpnCfg_set_default(&openvpnCfg);
    rpcServer.registerMessageHandler(app::rpcMessage::rpcMessageType::handle_openvpn_cfg, openvpn_cfg_handler);
}

bool openVpnManager_openvpnCfg_get(app::openvpnCfg_t *openvpnCfg_ptr) {

    if (openvpnCfg_ptr == NULL) {
        return false;
    }

    *openvpnCfg_ptr = openvpnCfg;

    return true;
}

bool openVpnManager_openvpnCfg_set(app::openvpnCfg_t *openvpnCfg_ptr) {

    bool config_changed;

    if (openvpnCfg_ptr == NULL) {
        syslog(LOG_CRIT, "openVpnManager_openvpnCfg_set: NULL pointer");
        return false;
    }

    if (openvpnCfg_valid(openvpnCfg_ptr)) {
        config_changed = memcmp (&openvpnCfg, openvpnCfg_ptr, sizeof(openvpnCfg)) != 0;
        openvpnCfg = *openvpnCfg_ptr;
    }

    if (config_changed) {
        openVpnManager_stop_openvpn_service();
    }

    if (openvpnCfg.state == false) {
        return true;
    }

    if (!openVpnManager_rsa_key_is_ok()) {
        syslog(LOG_ERR, "RSA Key Management is not ready for OpenVPN staring");
        goto err;
    }

    if (!openVpnManager_generate_openvpncfg()) {
        syslog(LOG_ERR, "Cannot create openvpn conf");
        goto err;
    }

    if (!openVpnManager_start_openvpn_service()) {
        syslog(LOG_ERR, "Cannot start openvpn service");
        goto err;
    }

    return true;

err:
    // any failes, set state back to false;
    openvpnCfg.state = false;

    return false;
}
